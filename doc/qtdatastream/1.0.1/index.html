<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-qtdatastream_buffer.ReadBuffer.html">ReadBuffer</a></li><li><a href="module-qtdatastream_socket.Socket.html">Socket</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_socket.Socket.html#detachSocket">detachSocket</a></li><li data-type='method'><a href="module-qtdatastream_socket.Socket.html#setSocket">setSocket</a></li><li data-type='method'><a href="module-qtdatastream_socket.Socket.html#updateSocket">updateSocket</a></li><li data-type='method'><a href="module-qtdatastream_socket.Socket.html#write">write</a></li></ul></li><li><a href="module-qtdatastream_transform.ReadTransform.html">ReadTransform</a></li><li><a href="module-qtdatastream_transform.WriteTransform.html">WriteTransform</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_transform.WriteTransform.html#.getBuffer">getBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QBool.html">QBool</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QBool.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QBool.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QByteArray.html">QByteArray</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QByteArray.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QByteArray.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QChar.html">QChar</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QChar.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QChar.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QClass.html">QClass</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QClass.html#.from">from</a></li></ul></li><li><a href="module-qtdatastream_types.QDateTime.html">QDateTime</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QDateTime.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QDateTime.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QDouble.html">QDouble</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QDouble.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QDouble.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QInt.html">QInt</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QInt.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QInt.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QInt64.html">QInt64</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QInt64.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QInt64.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QInvalid.html">QInvalid</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QInvalid.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QInvalid.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QList.html">QList</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QList.html#.of">of</a></li><li data-type='method'><a href="module-qtdatastream_types.QList.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QList.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QMap.html">QMap</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QMap.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QMap.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QShort.html">QShort</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QShort.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QShort.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QString.html">QString</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QString.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QString.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QStringList.html">QStringList</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QStringList.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QStringList.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QTime.html">QTime</a></li><li><a href="module-qtdatastream_types.QUInt.html">QUInt</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QUInt.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QUInt.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QUInt64.html">QUInt64</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QUInt64.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QUInt64.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QUserType.html">QUserType</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QUserType.html#.createComplexUserType">createComplexUserType</a></li><li data-type='method'><a href="module-qtdatastream_types.QUserType.html#.createUserType">createUserType</a></li><li data-type='method'><a href="module-qtdatastream_types.QUserType.html#.get">get</a></li><li data-type='method'><a href="module-qtdatastream_types.QUserType.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QUserType.html#.register">register</a></li><li data-type='method'><a href="module-qtdatastream_types.QUserType.html#~toBuffer">toBuffer</a></li></ul></li><li><a href="module-qtdatastream_types.QVariant.html">QVariant</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.QVariant.html#.coerceNumbersTo">coerceNumbersTo</a></li><li data-type='method'><a href="module-qtdatastream_types.QVariant.html#.read">read</a></li><li data-type='method'><a href="module-qtdatastream_types.QVariant.html#~toBuffer">toBuffer</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-qtdatastream_buffer.html">qtdatastream/buffer</a></li><li><a href="module-qtdatastream_serialization.html">qtdatastream/serialization</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_serialization.html#.Serializable">Serializable</a></li><li data-type='method'><a href="module-qtdatastream_serialization.html#.serialize">serialize</a></li></ul></li><li><a href="module-qtdatastream_socket.html">qtdatastream/socket</a></li><li><a href="module-qtdatastream_transform.html">qtdatastream/transform</a></li><li><a href="module-qtdatastream_types.html">qtdatastream/types</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_types.html#~qtype">qtype</a></li></ul></li><li><a href="module-qtdatastream_util.html">qtdatastream/util</a><ul class='methods'><li data-type='method'><a href="module-qtdatastream_util.html#.dateToJulianDay">dateToJulianDay</a></li><li data-type='method'><a href="module-qtdatastream_util.html#.julianDayToDate">julianDayToDate</a></li><li data-type='method'><a href="module-qtdatastream_util.html#.str">str</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="ReadTransform.html#event:data">data</a></li><li><a href="WriteTransform.html#event:data">data</a></li></ul>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><p><a href="https://npmjs.org/package/qtdatastream"><img src="https://nodei.co/npm/qtdatastream.png" alt="NPM"></a></p>
<p><a href="https://travis-ci.org/magne4000/node-qtdatastream"><img src="https://travis-ci.org/magne4000/node-qtdatastream.svg?branch=es2015" alt="Build Status"></a>
<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT"></a></p>
<p>Javascript <a href="http://doc.qt.io/qt-4.8/qdatastream.html">QDatastream</a> (de)serializer.</p>
<p>List of types handled for (de)serialization:
  QBool, QShort, QInt, QInt64, QUInt, QUInt64, QDouble, QMap, QList, QString, QVariant, QStringList, QByteArray, QUserType, QDateTime, QTime, QChar, QInvalid</p>
<h2>Getting Started</h2><p>Install the module with <code>npm install node-qtdatastream --production</code>,
or <code>npm install node-qtdatastream</code> for development purpose.</p>
<h2>Documentation</h2><p><a href="http://magne4000.github.io/qtdatastream/1.0.1/">Technical documentation</a></p>
<h3>Type inference</h3><p>Javascript types can be automatically converted to Qt Types, and here is the default behavior</p>
<h4>javascript to QClass</h4><table>
<thead>
<tr>
<th>javascript</th>
<th>QClass</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>QString</td>
</tr>
<tr>
<td>number</td>
<td>QUInt (this can be overloaded)</td>
</tr>
<tr>
<td>boolean</td>
<td>QBool</td>
</tr>
<tr>
<td>Array</td>
<td>QList&lt;QVariant&lt;?&gt;&gt;</td>
</tr>
<tr>
<td>Date</td>
<td>QDateTime</td>
</tr>
<tr>
<td>Map</td>
<td>QMap&lt;QString, QVariant&lt;?&gt;&gt;</td>
</tr>
<tr>
<td>Object</td>
<td>QMap&lt;QString, QVariant&lt;?&gt;&gt;</td>
</tr>
</tbody>
</table>
<p>You can always force any type to be coerced to any Qt type</p>
<pre class="prettyprint source lang-javascript"><code>const { QByteArray } = require('qtdatastream').types;
const s = &quot;hello&quot;; // If given to the writer, it will be coerced to QString
const qbytearray = QByteArray.from(s); // This will write the same string but as a QByteArray</code></pre><p>NB: you can change default behavior for number</p>
<pre class="prettyprint source lang-javascript"><code>const { QVariant, Types } = require('qtdatastream').types;
const n = 1; // Would be written as QUInt
QVariant.coerceNumbersTo(Types.DOUBLE); // Will now write any number as QDouble</code></pre><h4>QClass to javascript</h4><p>Qt Types are also converted to native javascript type automatically upon reading</p>
<table>
<thead>
<tr>
<th>QClass</th>
<th>javascript</th>
</tr>
</thead>
<tbody>
<tr>
<td>QString</td>
<td>string</td>
</tr>
<tr>
<td>QUInt</td>
<td>number</td>
</tr>
<tr>
<td>QInt</td>
<td>number</td>
</tr>
<tr>
<td>QUInt64</td>
<td>number</td>
</tr>
<tr>
<td>QInt64</td>
<td>number</td>
</tr>
<tr>
<td>QDouble</td>
<td>number</td>
</tr>
<tr>
<td>QShort</td>
<td>number</td>
</tr>
<tr>
<td>QBool</td>
<td>number</td>
</tr>
<tr>
<td>QList</td>
<td>Array</td>
</tr>
<tr>
<td>QStringList</td>
<td>Array&lt;string&gt;</td>
</tr>
<tr>
<td>QByteArray</td>
<td>Buffer</td>
</tr>
<tr>
<td>QMap</td>
<td>Object</td>
</tr>
<tr>
<td>QUserType</td>
<td>Object</td>
</tr>
<tr>
<td>QDateTime</td>
<td>Date</td>
</tr>
<tr>
<td>QTime</td>
<td>number</td>
</tr>
<tr>
<td>QChar</td>
<td>string</td>
</tr>
<tr>
<td>QInvalid</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h4>QUserType special treatment</h4><p>QUserType are special types defined by user (QVariant::UserType).</p>
<p>QUserType are defined like this <code>&lt;size:uint32&gt;&lt;bytearray of size&gt;</code>. bytearray
can be casted to string (but it is not a string as intended by Qt,
because it is UTF8 and not UTF16) : <code>bytearray.toString()</code>. The resulting string
is the QUserType key.</p>
<h5>Reader</h5><p>The Reader use an internal mechanism to know which parser must be used for each
QUserType. They are defined like this:</p>
<pre class="prettyprint source lang-javascript"><code>const { QUserType } = require('qtdatastream').types;
QUserType.register(&quot;NetworkId&quot;, qtdatastream.Types.INT); //NetworkId here is our key</code></pre><p>This tell the reader to decode <code>NetworkId</code> bytearray like and INT. But those
structures can be much more complicated:</p>
<pre class="prettyprint source lang-javascript"><code>const { QUserType } = require('qtdatastream').types;
QUserType.register(&quot;BufferInfo&quot;, [
    {id: qtdatastream.Types.INT},
    {network: qtdatastream.Types.INT},
    {type: qtdatastream.Types.SHORT},
    {group: qtdatastream.Types.INT},
    {name: qtdatastream.Types.BYTEARRAY}
]);</code></pre><p>The bytearray corresponding to this structure look like this :</p>
<pre class="prettyprint source"><code>  &lt;int32>&lt;int32>&lt;int16>&lt;int32>&lt;qbytearray></code></pre><p>The whole new type will be put in a new Object, the <code>id</code> key will contain the first
&lt;int32&gt;, the <code>network</code> key will contain the second &lt;int32&gt;, etc.
The definition is contained into an array to force a parsing order (here, <code>id</code> will
always be the first &lt;int32&gt; block).</p>
<p>UserTypes can also be nested, by specifying the usertype name instead of Qt type :</p>
<pre class="prettyprint source lang-javascript"><code>QUserType.register(&quot;BufferInfoContainer&quot;, [
    {id: qtdatastream.Types.INT},
    {bufferInfo: &quot;BufferInfo&quot;} // here we reference the BufferInfo QUserType
]);</code></pre><p>Keep in mind that if a usertype <code>X</code> references usertype <code>Y</code>, <code>Y</code> should be declared before <code>X</code>.</p>
<h5>Writer</h5><p>Custom usertypes can be defined as for Reader, with the help of <code>QUserType.register</code> method.</p>
<p>Writing UserType is done as follow:</p>
<pre class="prettyprint source lang-javascript"><code>const { Socket } = require('qtdatastream').socket;
const { QUserType } = require('qtdatastream').types;
const qtsocket = new Socket(myRealSocket);

const data = {
    &quot;BufferInfo&quot;: new QUserType(&quot;BufferInfo&quot;, {
        id: 2,
        network: 4,
        type: 5,
        group: 1,
        name: &quot;BufferInfo name&quot;
    })
});

qtsocket.write(data);</code></pre><p>Some more examples can be found in test folder.</p>
<h3>ES6/7</h3><p>ES7 decorators can be used to simplify serializable data representation</p>
<pre class="prettyprint source lang-javascript"><code>const { types: { QUserType, QString, QUInt, Types }, serialization: { Serializable, serialize } } = require('qtdatastream');
// Register usertype
QUserType.register('Network::Server', Types.MAP);

@Serializable('Network::Server')
export class Server {
    @serialize(QString, {in: 'HostIn', out: 'HostOut'))
    host;

    @serialize(QUInt, 'Port')
    port = 6667;

    @serialize(QUInt)
    sslVersion = 0;

    constructor(args) {
        this.blob = true; // will not be serialized at export
        Object.assign(this, args);
    }
}

const parsedUserType = {
    HostIn: 'myHost',
    Port: 1234
}; // This usually comes from qtsocket
const server = new Server(parsedUserType);
// server == {
//     host: 'myHost',
//     port: 1234,
//     sslVersion: 0
// }

// This will call server.export() method before sending to the server,
// which exports the object as dictated by Server class and 'Network::Server' usertype
qtsocket.write(server)</code></pre><p><code>Serializable</code> parameter (usertype) is optionnal. If unspecified, it will be exported as a <code>QMap</code>.</p>
<p>If <code>Serializable</code> class implements <code>_export</code> method, the return of this function will be used
instead of object own attributes.</p>
<pre class="prettyprint source lang-javascript"><code>@Serializable()
export class Server {
  _export() {
    return {
      'a': 'b'
    };
  }
}</code></pre><h2>Example</h2><pre class="prettyprint source lang-javascript"><code>const { Socket } = require('qtdatastream').socket;
const { QUserType } = require('qtdatastream').types;
const net = require('net');

var client = net.Socket();

// Connect to a Qt socket
// and write something into the socket
client.connect(65000, &quot;domain.tld&quot;, function(){
    const qtsocket = new Socket(client);

    // Here data is the already parsed response
    qtsocket.on('data', function(data) {
        //...
    });

    // Write something to the socket
    qtsocket.write({
        &quot;AString&quot;: &quot;BString&quot;,
        &quot;CString&quot;: 42
    });
});</code></pre><h2>Debugging</h2><p>Debug mode can be activated by setting environment variable DEBUG in your shell before launching your program:</p>
<pre class="prettyprint source"><code>export DEBUG=&quot;qtdatastream:*&quot;</code></pre><h2>License</h2><p>Copyright (c) 2017 JoÃ«l Charles
Licensed under the MIT license.</p></article>
    </section>






</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Mar 04 2018 23:02:40 GMT+0100 (CET) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>